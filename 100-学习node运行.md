= Introduction
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :bookmark:
:important-caption: :boom:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

我认为大多数开发者都在以一种错误的方式学习node。大多数关于node的教程都在关注Node生态，而不是Node运行本身，它们教学的终点在于使用各种各样的包（例如Express和Socket.IO）能做到什么，而不是node本身能够做到什么。

这有很多优势。Node是原生和灵活的，它并不提供一个完整的解决方案，而只是提供了一个丰富的运行环境让你完成你自己的解决方案。像Express.js和Socket.io这样的库更多的是一种完整的解决方案，因此教这些库显得更有意义，因为你可以让学习者使用这些完整的解决方案。

一般人会认为只有写像Express.js和Socket.io这样的库的程序员才需要了解关于node环境的一切，但是我不这样认为。一个扎实的node本体环境的理解是你在使用完整解决方案之前的最佳选择，你至少应该有足够的知识和信心去通过它的`源码`对一个包进行评估，这样你才能够对它的使用做出足够明智的选择。

== Node只是挑战

我先给你一些在看完这本书之后能够答上来的问题，以此检验一下你的Node知识水平，如果你能够回答出大多数的问题，那么这本书可能并不适合你。

* Node和V8引擎的关系是什么？Node不借助V8能否运行？

* 为什么在任何Node文件中声明全局变量时，它并不是所有模块的全局变量？

* 当你导出一个Node模块的api时，为什么有时候用`exports`而有时候用的是`module.exports`？

* 什么是调用栈？这是V8引擎的一部分吗？

* 什么是事件循环？这是V8引擎的一部分吗？

* `seetImmediate`和`process.nextTick`的区别是什么？

* `spawn`、`exec`和`fork`的主要区别是什么？

* 集群（cluster）模块是如何工作的？他和负载均衡器的区别是什么？

* 当调用栈和事件轮询都为空的时候会发生什么？

* V8中的对象和函数模板是什么？

* libuv是什么？node是如何使用它的？

* 在一个node进程退出时怎么样进行最后一个操作？这个操作可以异步完成吗？

* 除了V8和libiv，node还有没有其他的外部依赖？

* `uncaughtExecption`事件抛出说明进程出现了什么问题？它和`exit`事件有什么不同？

* require函数的五个主要步骤是什么？

* 如何检测本地模块是否存在？

* 什么是Node模块的循环依赖，如何避免它？

* require函数会自动尝试的三个文件扩展是什么？

* 在创建一个http服务器并为请求编写响应的时候，为什么需要end()函数？

* 使用文件系统的`*Sync`方法在什么时候可用？

* 如何只输出深度嵌套的对象的第一层？

* 为什么最上层的变量不是全局的？

* 对象的`exports`、`require`和`module`在每一个模块中都是全局可用的，但是为何在每一个模块中的表现都不同？

* 如果你用node运行只有一行`console.log(argument)`代码的JavaScript文件的，node会输出什么？

* 一个模块如何被其他模块和node命令同时获取到？

* node的内置流中有没有同时可读与可写的？

* 当`cluster.fork()`语句在node脚本中被调用时会发生什么？

* 使用事件发射器和使用简单的回调函数来允许异步执行代码的区别是什么？

* 可读流的*Paused*和*Flowing*模式有什么区别？

* 如何通过已连接的套接字读取数据？

* `require`函数总是缓存它获取的模块，如果你需要调用引用的模块中的代码多次的话要做什么？

* 当使用流工作的时候，什么时候用pipe函数，而什么时候使用事件？这两个方法可以结合使用吗？

== 基本原理

我会将其中的一些问题按原理分类。首先回答下列问题：

=== 什么是调用栈，它是V8引擎的一部分吗？

调用栈毫无疑问是V8的一部分，它是V8引擎用来跟踪函数调用的数据结构。每当我们调用一次函数，V8便会在调用栈中放置一个该函数的引用，对于每一个嵌套调用的其它函数也进行同样的操作，也包括递归调用自身的函数。

当函数的嵌套调用结束，V8就会*弹出*一个函数，然后使用该函数的返回值代替原来的位置

**** 
*为什么这对理解Node很重要？
* 因为一个Node进程中只会有一个调用栈，如果你的调用栈很繁忙，那么整个Node进程也会变得繁忙。一定要牢记这一点。

****

image::/images/picturenode12.svg[]

=== 什么是事件轮询？它是V8引擎的一部分吗？

事件轮询是由*libuv*库提供的，它并不是V8引擎的一部分。

事件轮询是一个处理外部事件并把它们转换为回调调用的实体。它是一个从事件队列中捕获事件、并把它们的回调函数放入调用栈的一个循环，它也是一个多阶段循环。

事件轮询是你需要理解的更大图景的一部分，为了理解事件轮询，你需要理解V8引擎发挥的作用，Node Api，并且理解代码是如何通过V8引擎排序好被调用的。

[提示]
Node Api提供像`setTimeout`和`fs.readFile`之类的函数，他们并不是JavaScript本身的一部分，他们只是Node提供的函数。

事件循环处在V8引擎的调用栈和不同的阶段和回调队列中间，它表现得像一个组织者，当调用栈为空的时候，事件循环便可以决定接下来运行什么。

=== 当调用栈和事件循环队列都为空的时候，Node会做什么？

进程会直接退出。

当你运行一个Node程序，Node会自动开始事件循环；当事件循环空闲并未没有其他的任务可做，进程便会退出。

为了使一个Node进程保持运行，你需要在事件队列中放置一些东西。例如，当你启动一个定时器或者一个HTTP服务器的时候，便是在告诉事件循环保持运行并关注发生的事件。

=== 除了V8和libuv， Node还有什么外部依赖？

以下都是一个Node进程可能用到的